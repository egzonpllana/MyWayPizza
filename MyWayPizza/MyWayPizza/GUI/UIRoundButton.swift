//
//  UIRoundButton.swift
//  MyWayPizza
//
//  Created by Egzon Pllana on 19.10.21.
//

import UIKit

@IBDesignable open class UIRoundButton: UIButton {

    // MARK: - Inspectable attributes

    /**
     When positive, the background of the layer will be drawn with
     rounded corners. Also effects the mask generated by the
     `masksToBounds' property. Defaults to zero. Animatable.

     (equivalent to layer.cornerRadius)
     */
    @IBInspectable open var cornerRadius: CGFloat {
        get { return layer.cornerRadius }
        set {
            layer.cornerRadius = max( 0.0, min( newValue, min( bounds.width, bounds.height ) / 2.0 ))
            // Apply shadowPath for performance
            shadowPath = UIBezierPath(roundedRect: bounds, cornerRadius: layer.cornerRadius).cgPath
        }
    }

    /**
     The width of the layer's border, inset from the layer bounds. The
     border is composited above the layer's content and sublayers and
     includes the effects of the `cornerRadius' property. Defaults to
     zero. Animatable.

     (equivalent to layer.borderWidth)
     */
    @IBInspectable open var borderWidth: CGFloat {
        get { return layer.borderWidth }
        set { layer.borderWidth = newValue }
    }

    /**
     The color of the layer's border. Defaults to opaque black. Colors
     created from tiled patterns are supported. Animatable.

     (equivalent to layer.borderColor)
     */
    @IBInspectable open var borderColor: UIColor? {
        get {
            guard let color = layer.borderColor else { return nil }
            return UIColor(cgColor: color)
        }
        set { layer.borderColor = newValue?.cgColor }
    }

    /**
     The color of the shadow. Defaults to opaque black. Colors created
     from patterns are currently NOT supported. Animatable.

     (equivalent to layer.shadowColor)
     */
    @IBInspectable open var shadowColor: UIColor? {
        get {
            guard let color = layer.shadowColor else { return nil }
            return UIColor(cgColor: color)
        }
        set { layer.shadowColor = newValue?.cgColor }
    }

    /**
     The opacity of the shadow. Defaults to 0. Specifying a value outside the
     [0,1] range will give undefined results. Animatable.

     (equivalent to layer.shadowOpacity)
     */
    @IBInspectable open var shadowOpacity: Float {
        get { return layer.shadowOpacity }
        set { layer.shadowOpacity = newValue }
    }

    /**
     The shadow offset. Defaults to (0, -3). Animatable.

     (equivalent to layer.shadowOffset)
     */
    @IBInspectable open var shadowOffset: CGSize {
        get { return layer.shadowOffset }
        set { layer.shadowOffset = newValue }
    }

    /**
     The blur radius used to create the shadow. Defaults to 3. Animatable.

     (equivalent to layer.shadowRadius)
     */
    @IBInspectable open var shadowRadius: CGFloat {
        get { return layer.shadowRadius }
        set { layer.shadowRadius = newValue }
    }

    /**
     The shape of the layer’s shadow. Animatable.

     (equivalent to layer.shadowPath)
     */
    fileprivate var shadowPath: CGPath? {
        get { return layer.shadowPath }
        set {
            layer.shadowPath = newValue
            // Mask the image view with rounded corners
            if let imageLayer = imageView?.layer {
                let maskLayer = CAShapeLayer()
                maskLayer.path = layer.shadowPath
                maskLayer.position = CGPoint(x: imageLayer.bounds.midX - layer.bounds.midX, y: imageLayer.bounds.midY - layer.bounds.midY)
                imageLayer.mask = maskLayer
            }
        }
    }

    /**
     The button’s background color when highlighted.
     Changes to this property can be animated. The default value is nil, which results in the same color as the background color.
     */
    @IBInspectable open var highlightedBackgroundColor: UIColor? {
        didSet {
            updateBackgroundColor()
        }
    }

    /**
     The button’s background color when selected.
     Changes to this property can be animated. The default value is nil, which results in the same color as the background color.
     */
    @IBInspectable open var selectedBackgroundColor: UIColor? {
        didSet {
            updateBackgroundColor()
        }
    }

    /**
     The button’s background color when disabled.
     Changes to this property can be animated. The default value is nil, which results in the same color as the background color.
     */
    @IBInspectable open var disabledBackgroundColor: UIColor? {
        didSet {
            updateBackgroundColor()
        }
    }

    override open var backgroundColor: UIColor? {
        didSet {
            originalBackgroundColor = backgroundColor
        }
    }

    override open var isEnabled: Bool {
        didSet {
            updateBackgroundColor()
        }
    }

    override open var isHighlighted: Bool {
        didSet {
            updateBackgroundColor()
        }
    }

    override open var isSelected: Bool {
        didSet {
            updateBackgroundColor()
        }
    }

    override open var contentMode: UIView.ContentMode {
        didSet {
            imageView?.contentMode = contentMode
        }
    }

    // MARK: - Initializers

    override public init(frame: CGRect) {
        super.init(frame: frame)
        setup()
    }

    required public init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        // Decode attributes
        cornerRadius = aDecoder.decodeObject(forKey: EncodingKey.cornerRadius.rawValue) as? CGFloat ?? cornerRadius
        borderWidth = aDecoder.decodeObject(forKey: EncodingKey.borderWidth.rawValue) as? CGFloat ?? borderWidth
        borderColor = aDecoder.decodeObject(forKey: EncodingKey.borderColor.rawValue) as? UIColor
        shadowColor = aDecoder.decodeObject(forKey: EncodingKey.shadowColor.rawValue) as? UIColor
        shadowOpacity = aDecoder.decodeObject(forKey: EncodingKey.shadowOpacity.rawValue) as? Float ?? shadowOpacity
        shadowOffset = aDecoder.decodeObject(forKey: EncodingKey.shadowOffset.rawValue) as? CGSize ?? shadowOffset
        shadowRadius = aDecoder.decodeObject(forKey: EncodingKey.shadowRadius.rawValue) as? CGFloat ?? shadowRadius
        highlightedBackgroundColor = aDecoder.decodeObject(forKey: EncodingKey.highlightedBackgroundColor.rawValue) as? UIColor
        selectedBackgroundColor = aDecoder.decodeObject(forKey: EncodingKey.selectedBackgroundColor.rawValue) as? UIColor
        disabledBackgroundColor = aDecoder.decodeObject(forKey: EncodingKey.disabledBackgroundColor.rawValue) as? UIColor
        setup()
    }

    // MARK: - Layout updates

    override open func layoutSubviews() {
        super.layoutSubviews()

        // Recompute cornerRadius from bounds
        cornerRadius = max(0.0, min(cornerRadius, min(bounds.width, bounds.height) / 2.0))
        shadowPath = UIBezierPath(roundedRect: bounds, cornerRadius: layer.cornerRadius).cgPath
    }

    override open func prepareForInterfaceBuilder() {
        super.prepareForInterfaceBuilder()
        setup()
    }

    // MARK: - Private

    fileprivate var originalBackgroundColor: UIColor!

    fileprivate func setup() {
        // Set the rasterization on for performances
        layer.shouldRasterize = true
        layer.rasterizationScale = UIScreen.main.scale

        // Compute cornerRadius from bounds
        cornerRadius = max(0.0, min(cornerRadius, min(bounds.width, bounds.height) / 2.0))

        // Remove clipping of the main layer to show shadows
        layer.masksToBounds = false
        layer.isOpaque = false

        updateBackgroundColor()

        // Needed for iOS12
        setNeedsLayout()
    }

    fileprivate func updateBackgroundColor() {
        let newBackgroundColor: UIColor?
        if isHighlighted, let highlightedBackgroundColor = highlightedBackgroundColor {
            newBackgroundColor = highlightedBackgroundColor
        } else if isSelected, let selectedBackgroundColor = selectedBackgroundColor {
            newBackgroundColor = selectedBackgroundColor
        } else if !isEnabled, let disabledBackgroundColor = disabledBackgroundColor {
            newBackgroundColor = disabledBackgroundColor
        } else {
            newBackgroundColor = originalBackgroundColor
        }
        super.backgroundColor = newBackgroundColor
    }

}

// MARK: - NSCoding

extension UIRoundButton/*: NSCoding*/ {

    fileprivate enum EncodingKey: String {
        case cornerRadius
        case borderWidth
        case borderColor
        case shadowColor
        case shadowOpacity
        case shadowOffset
        case shadowRadius
        case highlightedBackgroundColor
        case selectedBackgroundColor
        case disabledBackgroundColor
    }

    open override func encode(with aCoder: NSCoder) {
        super.encode(with: aCoder)
        aCoder.encode(cornerRadius, forKey: EncodingKey.cornerRadius.rawValue)
        aCoder.encode(shadowOpacity, forKey: EncodingKey.shadowOpacity.rawValue)
        aCoder.encode(shadowRadius, forKey: EncodingKey.shadowRadius.rawValue)
        aCoder.encode(shadowColor, forKey: EncodingKey.shadowColor.rawValue)
        aCoder.encode(shadowOffset, forKey: EncodingKey.shadowOffset.rawValue)
        aCoder.encode(borderWidth, forKey: EncodingKey.borderWidth.rawValue)
        aCoder.encode(borderColor, forKey: EncodingKey.borderColor.rawValue)
        aCoder.encode(highlightedBackgroundColor, forKey: EncodingKey.highlightedBackgroundColor.rawValue)
        aCoder.encode(selectedBackgroundColor, forKey: EncodingKey.selectedBackgroundColor.rawValue)
        aCoder.encode(disabledBackgroundColor, forKey: EncodingKey.disabledBackgroundColor.rawValue)
    }

}
